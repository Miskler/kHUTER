shader_type canvas_item;


// Converts vec4 to float
float rgba_to_float(vec4 value) {
	return (value.r + value.g + value.b) / 3.0 * value.a;
}

// Hash with vec2 input and vec2 output
vec2 hash22(vec2 seed){
	uvec2 k = uvec2(uint(0x456789ab), uint(0x6789ab45));
	uvec2 n = floatBitsToUint(seed);
	n = n ^ n.yx << uint(9);
	n = n ^ n.yx >> uint(1);
	n = n * k;
	n = n ^ n.yx << uint(1);
	n = n * k;
	return fract(vec2(n) / float(0xffffffff));
}

float perlin(vec2 pos) {
	vec2 pi = floor(pos); // Not the 3.14 pi, but "pos integer"
	vec2 pf = fract(pos); // Pos fract
	
	vec2 w = smoothstep(0.0, 1.0, pf); // Interpolated pf
	
	return mix (mix(dot(hash22(pi + vec2(0.0, 0.0)) * 2.0 - 1.0, pf - vec2(0.0, 0.0)), // Top Left
					dot(hash22(pi + vec2(1.0, 0.0)) * 2.0 - 1.0, pf - vec2(1.0, 0.0)), w.x), // Top Right
				mix(dot(hash22(pi + vec2(0.0, 1.0)) * 2.0 - 1.0, pf - vec2(0.0, 1.0)), // Bottom Left
					dot(hash22(pi + vec2(1.0, 1.0)) * 2.0 - 1.0, pf - vec2(1.0, 1.0)), w.x), // Bottom Right
				w.y); // Interpolate top and bottom, resulting 2D noise
}

float fbm_perlin(vec2 pos, int octaves, float persistence, float lacunarity) {
	float noise = 0.0;
	float sum = 1.0;
	noise += sum * perlin(pos);
	pos = lacunarity * pos;
	for (int i = 0; i < octaves - 1; i++) {
		sum *= persistence;
		noise += sum * perlin(pos);
		pos = lacunarity * pos;
	}
	return noise * 0.5 + 0.5;
}

// Hash with float input and float output
float hash11(float seed){
	uint n = floatBitsToUint(seed);
	n = n ^ n << uint(9);
	n = n ^ n >> uint(1);
	n = n ^ n << uint(1);
	n = n * uint(0x456789ab);
	return fract(float(n) / float(0xffffffff));
}

float range(float value, float from, float to) {
	value *= to - from;
	value += from;
	return value;
}

float saturate(float value) {
	return clamp(value, 0.0, 1.0);
}

vec2 rotate(vec2 uv, vec2 pivot, float rot) {
	uv -= pivot;
	uv = vec2(cos(rot) * uv.x + sin(rot) * uv.y,
				-sin(rot) * uv.x + cos(rot) * uv.y);
	uv += pivot;
	return uv;
}

void fragment() { 
	vec4 main_image = vec4(0.0);

	vec2 Base_UV = UV;  // Create UV with transformations
	float Distortion = fbm_perlin(UV * 3.0, 1, 0.5, 2.0);  // Create 2D perlin noise variable
	Base_UV = Base_UV + (vec2(Distortion, Distortion) - vec2(0.5)) * vec2(0.1, 0.1);  // Distort Base UV
	float Columns = 8.0;  // Create new float variable
	float X = floor(Base_UV.x * Columns) / Columns;  // Create new float variable
	float Y_Offset = range(hash11(float(X)), 0.0, 1.0);  // Create a variable with random value
	vec2 Rain_UV = vec2(Base_UV.x, Base_UV.y);  // Create new vec2 variable
	Rain_UV = Rain_UV - vec2(0.0, Y_Offset + TIME);  // Move Rain UV

	// Tile Rain UV
	Rain_UV *= vec2(8.0, 1.0);
	Rain_UV = fract(Rain_UV);

	// Draw a gradient on the main image
	float new_gradient_offsets[3] = {0.0, 0.89777, 1.0};
	vec4 new_gradient_colors[3] = { vec4(0.0, 0.0, 0.0, 1.0), 
									vec4(1.0, 1.0, 1.0, 1.0),
									vec4(0.0, 0.0, 0.0, 1.0)
									};
	vec4 new_gradient_grad = new_gradient_colors[0];
	for (int i = 0; i < 2; i++) {
		float base = rotate(Rain_UV, vec2(0.5, 0.5), radians(90.0)).x;  // Base gradient
		base -= new_gradient_offsets[i];  // Offset base gradient to current point
		base /= new_gradient_offsets[i + 1] - new_gradient_offsets[i];  // Resize gradient to next point
		base  = saturate(base);  // Make sure this value is only between 0.0 to 1.0
		new_gradient_grad = mix(new_gradient_grad, new_gradient_colors[i + 1], base);
	}
	main_image.rgb = mix(main_image.rgb, new_gradient_grad.rgb, new_gradient_grad.a);
	main_image.a = mix(main_image.a, 1.0, new_gradient_grad.a);

	// Draw a gradient on the main image
	float new_gradient2_offsets[3] = {0.2, 0.5, 0.8};
	vec4 new_gradient2_colors[3] = {vec4(0.0, 0.0, 0.0, 1.0), 
									vec4(1.0, 1.0, 1.0, 1.0),
									vec4(0.0, 0.0, 0.0, 1.0)
									};
	vec4 new_gradient2_grad = new_gradient2_colors[0];
	for (int i = 0; i < 2; i++) {
		float base = rotate(Rain_UV, vec2(0.5, 0.5), radians(0.0)).x;  // Base gradient
		base -= new_gradient2_offsets[i];  // Offset base gradient to current point
		base /= new_gradient2_offsets[i + 1] - new_gradient2_offsets[i];  // Resize gradient to next point
		base  = saturate(base);  // Make sure this value is only between 0.0 to 1.0
		new_gradient2_grad = mix(new_gradient2_grad, new_gradient2_colors[i + 1], base);
	}
	main_image.rgb = mix(mix(main_image.rgb, new_gradient2_grad.rgb, new_gradient2_grad.a), mix(main_image.rgb, main_image.rgb * new_gradient2_grad.rgb, new_gradient2_grad.a), main_image.a);
	main_image.a = mix(main_image.a, 1.0, new_gradient2_grad.a);

	// Colorize Main Image
	float new_colorized_value_offsets[3] = {0.10223, 0.27974, 0.894981};
	vec4 new_colorized_value_colors[3] = {  vec4(1.0, 1.0, 1.0, 0.0), 
											vec4(1.0, 1.0, 1.0, 1.0),
											vec4(0.459738, 0.93644, 1.0, 0.498039)
											};
	vec4 new_colorized_value_grad = new_colorized_value_colors[0];
	for (int i = 0; i < 2; i++) {
		float base = rgba_to_float(main_image);  // Base gradient
		base -= new_colorized_value_offsets[i];  // Offset base gradient to current point
		base /= new_colorized_value_offsets[i + 1] - new_colorized_value_offsets[i];  // Resize gradient to next point
		base  = saturate(base);  // Make sure this value is only between 0.0 to 1.0
		new_colorized_value_grad = mix(new_colorized_value_grad, new_colorized_value_colors[i + 1], base);
	}
	main_image.rgb = new_colorized_value_grad.rgb;
	main_image.a = new_colorized_value_grad.a;
	COLOR = main_image;
}